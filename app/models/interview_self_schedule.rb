# frozen_string_literal: true

class InterviewSelfSchedule < ApplicationRecord
  # Status constants
  STATUSES = %w[pending scheduled expired cancelled].freeze

  # Associations
  belongs_to :interview

  # Delegations
  delegate :application, :candidate, :job, to: :interview
  delegate :organization, to: :interview

  # Validations
  validates :scheduling_starts_at, presence: true
  validates :scheduling_ends_at, presence: true
  validates :slot_duration_minutes, presence: true, numericality: { greater_than: 0, less_than_or_equal_to: 480 }
  validates :buffer_minutes, presence: true, numericality: { greater_than_or_equal_to: 0 }
  validates :timezone, presence: true
  validates :status, presence: true, inclusion: { in: STATUSES }
  validates :token, presence: true, uniqueness: true

  validate :scheduling_window_valid
  validate :available_slots_format

  # Callbacks
  before_validation :generate_token, on: :create
  before_validation :set_default_status, on: :create

  # Scopes
  scope :pending, -> { where(status: "pending") }
  scope :scheduled, -> { where(status: "scheduled") }
  scope :expired, -> { where(status: "expired") }
  scope :cancelled, -> { where(status: "cancelled") }
  scope :active, -> { where(status: %w[pending scheduled]) }

  # Status helpers
  def pending?
    status == "pending"
  end

  def scheduled?
    status == "scheduled"
  end

  def expired?
    status == "expired"
  end

  def cancelled?
    status == "cancelled"
  end

  def can_schedule?
    pending? && scheduling_window_open?
  end

  def scheduling_window_open?
    now = Time.current
    now >= scheduling_starts_at && now <= scheduling_ends_at
  end

  # Slot management
  def slots
    return [] unless available_slots.is_a?(Array)

    available_slots.map do |slot|
      {
        start_time: Time.zone.parse(slot["start_time"]),
        end_time: Time.zone.parse(slot["end_time"]),
        available: slot["available"] != false
      }
    end
  rescue ArgumentError
    []
  end

  def available_slots_list
    slots.select { |s| s[:available] }
  end

  def add_slot(start_time, end_time = nil)
    end_time ||= start_time + slot_duration_minutes.minutes

    self.available_slots ||= []
    self.available_slots << {
      "start_time" => start_time.iso8601,
      "end_time" => end_time.iso8601,
      "available" => true
    }
  end

  def remove_slot(start_time)
    return unless available_slots.is_a?(Array)

    self.available_slots = available_slots.reject do |slot|
      Time.zone.parse(slot["start_time"]) == start_time
    end
  end

  def mark_slot_unavailable(start_time)
    return unless available_slots.is_a?(Array)

    self.available_slots = available_slots.map do |slot|
      if Time.zone.parse(slot["start_time"]) == start_time
        slot.merge("available" => false)
      else
        slot
      end
    end
  end

  # Scheduling
  def schedule_slot!(start_time)
    raise StandardError, "Cannot schedule - not in pending status" unless pending?
    raise StandardError, "Scheduling window has closed" unless scheduling_window_open?

    slot = slots.find { |s| s[:start_time] == start_time && s[:available] }
    raise StandardError, "Selected slot is not available" unless slot

    transaction do
      self.selected_slot = start_time
      self.scheduled_at = Time.current
      self.status = "scheduled"
      save!

      # Update the interview with the scheduled time
      interview.update!(
        scheduled_at: start_time,
        duration_minutes: slot_duration_minutes
      )

      # Confirm the interview if it's in scheduled state
      interview.confirm if interview.can_confirm?
    end

    self
  end

  # Expiration
  def check_expiration!
    return unless pending?
    return if scheduling_ends_at > Time.current

    update!(status: "expired")
  end

  def cancel!
    update!(status: "cancelled")
  end

  # URL helpers
  def scheduling_url
    # This would be generated by the routes
    "/schedule/#{token}"
  end

  # Display helpers
  def status_label
    status.titleize
  end

  def status_color
    case status
    when "pending" then "yellow"
    when "scheduled" then "green"
    when "expired" then "gray"
    when "cancelled" then "red"
    else "gray"
    end
  end

  def scheduling_window_formatted
    start_str = scheduling_starts_at.in_time_zone(timezone).strftime("%B %d, %Y at %I:%M %p")
    end_str = scheduling_ends_at.in_time_zone(timezone).strftime("%B %d, %Y at %I:%M %p")
    "#{start_str} - #{end_str} (#{timezone})"
  end

  def selected_slot_formatted
    return nil unless selected_slot

    selected_slot.in_time_zone(timezone).strftime("%B %d, %Y at %I:%M %p %Z")
  end

  private

  def generate_token
    self.token ||= SecureRandom.urlsafe_base64(32)
  end

  def set_default_status
    self.status ||= "pending"
  end

  def scheduling_window_valid
    return unless scheduling_starts_at && scheduling_ends_at

    if scheduling_ends_at <= scheduling_starts_at
      errors.add(:scheduling_ends_at, "must be after scheduling starts at")
    end
  end

  def available_slots_format
    return if available_slots.blank?

    unless available_slots.is_a?(Array)
      errors.add(:available_slots, "must be an array")
      return
    end

    available_slots.each_with_index do |slot, index|
      unless slot.is_a?(Hash) && slot["start_time"].present? && slot["end_time"].present?
        errors.add(:available_slots, "slot #{index + 1} must have start_time and end_time")
      end
    end
  end
end
